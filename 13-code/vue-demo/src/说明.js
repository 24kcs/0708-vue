/**
 * main.js中Vue实例多次,浏览器中vue插件,就可以看到多个root
 * data为什么是函数,而不是对象
 * 多个组件同时共用一个data,如果是对象,只能执行一次,但是如果是函数可以多次执行调用,但是返回不同对象
 * 正向代理,反向代理
 * 正向代理:隐藏客户端(翻墙)
 * 客户端请求--->proxy(中间件)针对服务器隐藏的客户端--->服务器
 * 反向代理:隐藏真实服务端(proxy代理的是服务器)
 * 客户端请求--->proxy(中间件)请求空闲多(压力小)的服务器--->服务器(多个服务器)
 * 
 * 
 *  1.插槽:
 *  1)普通插槽：普通插槽,没有名字,直接传值即可
 *  2)具名插槽: 有名字,传值的时候,需要使用名字的标识,其他的内容不能传过去
 *  3)作用域插槽: 把子组件中插槽要使用的数据传入到了父级组件中,父级组件就可以控制子级组件中插槽的数据的显示方式
 *  2.Vue中的混合
 * 
 * 
 *  3. 事件:
 *  Vue中事件分类:
 *  1) 原生事件:在普通的标签上直接使用DOM的事件(DOM中自带的事件名字),
 *    在组件标签上使用DOM事件之后,加上一个.native修饰符
 * 
 *  如果是组件使用了事件,一定要在该事件后面使用.native修饰符,此时这个事件才是真正的原生事件,此时在该组件内容中最外面的包裹的这个标签上会添加这个事件,
 * 如果是原生事件,只要有回调函数,事件触发后,回调函数中的代码必然会执行
 * 
 *  2) 自定义事件:
 *   1)首先这个事件的名字是自己定义的(无论是普通标签还是组件标签)
 *   2)如果在组件标签上使用的是DOM自带的事件或者是自定义的事件(没有.native修饰)
 * 
 * 如果是自定义事件,虽然有回调函数,但是只要没有手动的分发,该事件的回调函数中的代码是不会执行
 * 
 * 
 * 4. 双向数据绑定
 *  原理: 获取当前文本框的value值,重新赋值给表达式,但是需要配合input事件
 * input :value="msg" @input="msg=fsdffsfsfsfsd"
 *  <p>{{msg}}</p>
 * 
 *  组件中使用v-model(明确:实际上里面有@input事件----此时该事件是自定义事件,)获取文本框的值,改变v-model="msg"msg这个表达式的值-----必须要进行分发---什么时候分发?组件中的input标签的input事件触发的时候,就会使用$emit()方法对传过来的自定义input事件进行分发,同时把我当前文本的值也传过去
 * 
 * 
 * 
 * 
 * 
 * 插槽:
 * 1.普通插槽:普通插槽的作用:还是占位,如果传入内容,则插槽原来中的内容就会被替换,可以传入任何内容,如果不传入内容,则显示的是插槽中原来的内容
 * 2.具名插槽:具名插槽的作用:还是占位,具名插槽传入数据,必须有name属性,外部需要使用slot="name属性的值"才可以正常的传值和使用
 * 总结；无论是普通插槽还是具名插槽---他们的作用,或者说最终的目的:组件之间的通信(传值),普通插槽和具名插槽都是父级组件向子级组件传递数据
 * 3.作用域插槽:需要使用<template slot-scope="slotProps"> 模版,同时需要使用slot-scope属性来获取传入的值(子级组件向父级组件传递数据,如果父级组件需要该数据,那么需要使用slot-scope="slotProps"来进行接收,子级组件中需要使用v-bind强制绑定数据的方式进行传递数据(:的方式依然可以))这样,父级组件可以使用子级组件中的数据了
 * 混合(混入)
 * vue中的混入mixins---该配置在组件的选项中书写
 * 什么时候会用到vue中的混入?
 * 多个组件有共同的选项内容的时候,可以单独的抽取出来,放在一个Mixin.js文件(名字无所谓,关键是,该文件中也需要把该对象暴露出来)在需要使用该混合的组件的文件中,通过mixins:[]的方式进行引入,这样,该组件就可以使用混合中的选项内容了,混合中的选项内容会自动的进入到该组件的选项中(配置)
 * 选项:组件对象中的配置内容
 * 
 * 组件:动态组件/缓存组件/异步组件
 * 动态组件:静态的方式引入(import的方式引入),需要在当前的组件中通过<component>标签,并且配合:is="动态的表达式",来设置动态组件-----
 * 动态组件也可以做切换页面的效果(不是真正意义的切换页面)---相当于做tab切换的效果
 * 
 * 缓存组件:使用<keep-alive>标签包裹后就是一个缓存组件
 * 缓存路由:使用<keep-alive>标签包裹后就是一个缓存路由组件
 * 异步组件:作用--按需引入
 * 
 * 项目中遇到了什么问题?怎么解决的?
 * 
 * 1.性能优化的内容
 * 2.better-scroll----滑动操作---
 * 
 * 事件:
 * vue中的事件:
 * 1.原生DOM事件:使用的事件的名字是DOM中自带的事件名字
 * 2.自定义事件:组件中自己定义的事件或者使用的是原生DOM事件的名字,但是没有使用.native修饰
 * 3.原生的DOM事件中的回调函数,只要事件触发,该回调函数就会自动的分发(里面的代码就会自动的执行)
 * 4.组件中的事件,如果是原生DOM事件,该组件中的所有的标签都会触发该事件(冒泡),该事件应该是给了该组件中的根标签了
 * 5.如果是组件中定义了自定义的事件,该事件的回调函数,需要自己手动的进行分发($emit('事件名字','回调函数'))
 * 组件中@click.native="" 原生DOM事件,
 * 
 * 响应式数据:
 * 
 * 
 * v-model双向数据绑定:
 * 1.如果直接在当前的组件中的文本框上使用v-model,p标签中使用插值,此时可以直接实现双向数据绑定
 * 2.在组件中使用v-model=""的这个指令,不能自动的实现双向数据绑定,原因:v-model指令可以拆分为:@input=""事件和:value=""强制绑定数据,二者缺一不可,由于@input事件在组件中直接使用,此时@input事件不是原生的DOM事件,而是一个自定义事件,如果是这样,需要在该组件的内部手动的分发该事件(@input事件),这样才能实现双向数据绑定
 * 
 * 3.在组件中不使用v-model指令,同样可以实现双向数据绑定的效果,:value="" @input=""
 * 4.无论是在组件中使用v-model指令还是在组件中使用拆分方式(:value="",@input=""),都需要在组件内部手动的分发该事件的回调函数
 * v-model指令也可以实现标签和标签之间的数据传递
 * v-model双向数据绑定的原理:
 * 在页面渲染之前,
 * 
 * 路由守卫:监视-和执行
 * 全局前置路由守卫:监视跳转的地址,限制跳转的连接方向,如果路由通过路由守卫进行限制后,那么路由在跳转的时候,就会有条件进行限制
 * 组件内的路由守卫:作用同上
 * to:目标的路由对象
 * from:即将离开的路由
 * next:放行,可以无参数,可以传地址,可以传入回调
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 520------
 * 插槽:
 * 1.普通插槽,没有名字,可以直接使用,可以随意的传入内容，父级组件传向子级组件
 * 2.具名插槽(命名插槽),有名字,使用的时候,需要携带name中的值,按照name的值进行占位传值的,父级组件传向子级组件
 * 3.作用域插槽:需要使用<template>配合slot-scope属性来获取子组件中传递给父级组件的数据
 * 
 * 混合(混入)
 * 在Vue中如果多个组件中有相同的配置选项,可以抽取到一个js文件中,然后在该组件的配置选项中,引入这个文件暴露出来的对象,需要使用mixins:[]的方法引入,该组件就可以使用混合中的配置选项内容了
 * 
 * 组件:
 * 动态组件:在页面中该组件的生命周期随时可以被干掉,有动态切换的效果
 * 缓存组件:使用<keep-alive> 进行包裹,可以进行缓存
 * 异步组件：异步加载产生的组件,可以实现按需引入的方式,演示了三种异步组件的注册
 * 
 * 
 * 事件:
 * 原生事件:原生DOM事件,
 * 1.在标签上用到的事件,该事件是DOM中自带的 <p @click="">
 * 2.在组件上用到的事件,该事件是DOM中自带的,并且使用了.native进行修饰 <Event1 @click.native="" />
 * 自定义事件:
 * 1.无论是在标签上还是在组件上使用了自己定义的事件 <p @xxx="">
 * 2.在组件上使用的事件没有使用.native修饰 <Event2 @keydown="" />
 * 
 * 原生事件的回调函数,会自动的执行(该事件触发,回调函数会自动的执行)
 * 自定义事件的回调函数,不会自动的执行(该事件触发后,需要自己手动触发(分发))$emit()
 * 
 * 组件中如果有事件,该组件内部的所有的标签都可以触发该事件,原因:事件被绑定到了组件中的根标签上了,所有的子级的标签之所以可以触发该事件,是因为有事件冒泡
 * 
 * 
 * 事件总线: 可以做到任意组件之间的通信
 * 
 * 响应式数据；数据变化了,界面也会随之变化
 * data中的数据是响应式的(return中),会代理给vm实例(子级组件对象),但是vm下的数据不会代理给data,data中不会有vm中添加的属性,
 * 页面中如果一个响应式的数据发生变化,非响应式的数据在页面中也变化了,不是响应式数据,只是因为页面重新渲染了
 * Vue.set()方法可以添加响应式属性,前提的是对象也要是响应式
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 12-2笔记
 * 普通插槽:仅仅是slot标签,内部什么属性也没有,直接在某个组件中调用(父级组件),并且在父级组件中向这个插槽内部可以传入任何内容,不需要有任何的标识,可以直接使用
 * 普通插槽作用:父级组件和子级组件之间通信
 * 
 * 具名插槽(命名插槽):该插槽内部使用了name属性,有名字,也是占位的作用,父级组件中可以向插槽内部传入数据,
 * 具名插槽作用:父级组件和子级组件之间通信
 * 
 * 作用域插槽；插槽本身就是占位,然后向插槽内部传递动态数据,然后在父级组件中调用该插槽的时候传入相关的标签,进行占位,需要配合template和v-slot来使用,父级组件内部可以得到插槽中传入的动态数据,可以直接进行使用
 * 作用域插槽作用:父级组件和子级组件(子级组件和父级组件之间)相互通信
 * 
 * 
 * Vue中组件之间通信的理解?
 * 所谓的组件之间通信其实也就是不同组件之间传递数据,一般父子组件之间,兄弟组件之间,任意组件之间
 * 我理解在Vue中大概有这么几个,比如:props,自定义事件,插槽,事件总线,PubSub(也可以在React中使用),Vuex
 * props:父子组件之间通信
 * 自定义事件:父子组件之间通信(子级组件向父级组件传递数据)
 * 插槽:普通插槽,具名插槽,作用域插槽(相互)
 * Vuex:任意组件之间通信
 * 
 * 混合mixins在组件内部的配置对象中可以进行使用,主要用于,各个组件之间有相同的属性或者方法或者计算属性....多个组件有共同的内容,此时可以抽取到一个mixin.js文件中,在需要使用这些内容的组件内容通过mixins:[]的方式进行配置
 * 
 * 动态组件:首先在界面中该组件可以被切换显示或者隐藏(显示或者隐藏:当前这个组件使用或者被卸载)
 * 如果想要使用动态组件,必须使用<component :is="组件名字" />来进行动态组件的切换
 * 
 * 缓存组件:使用<keep-alive>进行包裹,此时这个组件就是缓存组件,缓存组件是不会被卸载的
 * 异步组件:在界面中需要该组件的时候再加载进来
 * 异步组件3种定义方式:
 * 1)工厂函数,直接写组件的定义代码
 * 2)工厂函数,内部通过require引入外部组件
 * 3)工厂函数,内部通过import引入外部组件
 * 
 * 
 * 原生事件:DOM中自带的事件,或者组件内部使用了.native修改的事件,或者该事件定义后可自动触发（不严谨的）
 * 自定义事件:DOM中本身没有该事件,自己定义的或者组件中没有使用.native
 * 
 * 原生事件例子: <button @click="">按钮</button> <Test @click.native="" />
 * 自定义事件例子: <button @xxx="">按钮</button> <Test @click="" />
 * 
 * 如果是自定义事件,一定要手动分发,如果是原生事件,事件触发后自动的会调用回调函数
 * 
 * 双向数据绑定:v-model指令,该指令内部是:value属性配合@input事件使用,@input事件需要得到当前的事件源的value值,重新赋值给value属性才可以使用
 * 
 * 组件上直接使用v-model无效,需要在组件内部先接收value属性,并且在文本框内部使用---> :value="value" @input="$emit('input',$event.target.value)"
 * 双引号中的value,是v-model中的value属性值
 * 标签上@input---->是当前文本框的原生input事件
 * "input"----->v-model中自定义的input事件
 * 在标签中的@input事件内部需要手动的分发自定义的input事件
 * 组件上使用v-model---->就相当于 :value="msg" @input=""事件
 * 
 * 
 * 
 * 
 * 响应式数据:数据变化了,界面也会变化
 * 非响应式数据:数据变化了,界面不会变化
 * 
 * 响应式数据:如果要添加响应式数据,首先要保证当前的数据是一个响应式的数据,在这个数据中才能添加响应式的数据
 * 
 */
